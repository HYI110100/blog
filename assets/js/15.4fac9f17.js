(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{415:function(a,t,r){"use strict";r.r(t);var s=r(2),v=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"let、var和const的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#let、var和const的区别"}},[a._v("#")]),a._v(" let、var和const的区别")]),a._v(" "),t("p",[a._v("var 变量提升，let 暂时性死区 作用域，const 不能修改值 作用域")]),a._v(" "),t("h2",{attrs:{id:"数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[a._v("#")]),a._v(" 数据类型")]),a._v(" "),t("p",[a._v("基本类型：字符串（string）、数字（number）、布尔（boolean）、未定义（undefined）、空（null）、大整数（bigint）、符号（symbol）"),t("br"),a._v("\n引用类型：方法（Function），对象（Object）、数组（Array）、Map、Set、Date")]),a._v(" "),t("h2",{attrs:{id:"map、set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map、set"}},[a._v("#")]),a._v(" Map、Set")]),a._v(" "),t("p",[a._v("Map有序的键值储存"),t("br"),a._v("\nSet唯一的类数组储存")]),a._v(" "),t("h2",{attrs:{id:"堆和栈的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆和栈的区别"}},[a._v("#")]),a._v(" 堆和栈的区别")]),a._v(" "),t("p",[a._v("栈 大小是固定的，存放 基本类型，存取速度比堆快"),t("br"),a._v("\n堆 大小不固定，存放 引用类型数据")]),a._v(" "),t("h2",{attrs:{id:"数据的深浅拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据的深浅拷贝"}},[a._v("#")]),a._v(" 数据的深浅拷贝")]),a._v(" "),t("p",[a._v("浅拷贝 拷贝引用地址"),t("br"),a._v("\n深拷贝 拷贝数据"),t("br"),a._v(" "),t("br"),a._v("\n深拷贝的实现与缺陷"),t("br"),a._v("\nJSON 循环引用对象无法正确实现深拷贝、new Date的对象会转换成字符串、函数和undefined会丢失"),t("br"),a._v("\n循环递归 考虑除对象之外的数据类型、循环引用对象")]),a._v(" "),t("h2",{attrs:{id:"this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[a._v("#")]),a._v(" this")]),a._v(" "),t("p",[a._v("this 对象，不同函数指向不同，（#普通函数和箭头函数）"),t("br"),a._v("\n绑定规则 new，显示绑定，隐式绑定，默认绑定")]),a._v(" "),t("h2",{attrs:{id:"普通函数和箭头函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#普通函数和箭头函数"}},[a._v("#")]),a._v(" 普通函数和箭头函数")]),a._v(" "),t("p",[a._v("箭头函数 this是函数上下文环境对象的，不能使用new构造函数"),t("br"),a._v("\n普通函数 this是谁调用就指向谁，可以使用new构造函数"),t("br"),a._v("\n（#call、apply 、bind）")]),a._v(" "),t("h2",{attrs:{id:"call、apply-、bind"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#call、apply-、bind"}},[a._v("#")]),a._v(" call、apply 、bind")]),a._v(" "),t("p",[a._v("call和apply 立即修改"),t("br"),a._v("\nbind 返回函数执行函数修改。"),t("br"),a._v("\napply传参不一样，它只接受一个类数组的参数"),t("br"),a._v("\ncall，bind是（obj，val，val,val....） |  apply（obj，[val,val,val...]）")]),a._v(" "),t("h2",{attrs:{id:"判断数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#判断数据类型"}},[a._v("#")]),a._v(" 判断数据类型")]),a._v(" "),t("p",[a._v("typeof判断 基本类型（判断结果：基本类型）和undefined（undefined），NaN（number）和null、引用类型（object）没法准确判断"),t("br"),a._v("\ninstanceof判断 引用类型。"),t("br"),a._v("\n构建函数判断（[].constructor === Array），isNaN，数组的isArray，toString配合call来判断")]),a._v(" "),t("h2",{attrs:{id:"instanceof的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#instanceof的原理"}},[a._v("#")]),a._v(" instanceof的原理")]),a._v(" "),t("p",[a._v("内部通过原型链的方式来判断是否为构建函数的实例")]),a._v(" "),t("h2",{attrs:{id:"原型、原型链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型、原型链"}},[a._v("#")]),a._v(" 原型、原型链")]),a._v(" "),t("p",[a._v("提供共享属性的对象"),t("br"),a._v("\n对象有__proto__  ，constructor --\x3e 构造函数 - prototype  --\x3e原型"),t("br"),a._v("\n__proto__一层一层，顶层 Object再往上 null 就原型链"),t("br"),a._v("\n优点：是共用数据方法，通过原型链找，不用每一个对象都带数据方法。"),t("br"),a._v("\n缺点：是共用的话一个地方修改，会影响到其他地方。"),t("br"),a._v("\n原型可以做继承，（#继承）")]),a._v(" "),t("h2",{attrs:{id:"继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[a._v("#")]),a._v(" 继承")]),a._v(" "),t("p",[a._v("子类通过继承父类，获取父类的属性和方法。"),t("br"),a._v("\n常见继承实现，优缺点看链接 "),t("a",{attrs:{href:"http://alanyf.site/blog/#/article/5ff52e743b420b7fc54e7de9",target:"_blank",rel:"noopener noreferrer"}},[a._v("JavaScript面向对象&继承"),t("OutboundLink")],1)]),a._v(" "),t("h2",{attrs:{id:"new做了什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#new做了什么"}},[a._v("#")]),a._v(" new做了什么")]),a._v(" "),t("p",[a._v("创建新对象，新对象继承了函数的原型，修改this，返回对象。")]),a._v(" "),t("h2",{attrs:{id:"es6新特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6新特性"}},[a._v("#")]),a._v(" es6新特性")]),a._v(" "),t("p",[a._v("箭头函数、字符串模板、let const、class声明类、解构赋值、Promise、Es6模块化、参数默认值等等")]),a._v(" "),t("h2",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[a._v("#")]),a._v(" Promise")]),a._v(" "),t("p",[a._v("异步任务解决方案，链式调用避免回调地狱"),t("br"),a._v("\n三种状态 pending，fulfilled，rejected"),t("br"),a._v("\nAPI all（全部请求完更改状态），race（一个请求完更改状态）")]),a._v(" "),t("h2",{attrs:{id:"作用域、作用域链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域、作用域链"}},[a._v("#")]),a._v(" 作用域、作用域链")]),a._v(" "),t("p",[a._v("变量的作用的范围"),t("br"),a._v("\n全局作用域 js最大一层任意作用域都可以访问"),t("br"),a._v("\n函数作用域 函数内部定义，函数执行结束变量销毁"),t("br"),a._v("\n块级作用域 {}包裹 ，if块、while块、for块、try/catch/finallyd等都会产生块级作用域"),t("br"),a._v("\n作用域链 局部作用域到全局作用域依次查找")]),a._v(" "),t("h2",{attrs:{id:"闭包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[a._v("#")]),a._v(" 闭包")]),a._v(" "),t("p",[a._v("定义在函数内部的函数 并且能够被函数外部引用"),t("br"),a._v("\n优点：变量持久化 防止变量污染"),t("br"),a._v("\n缺点：内存泄露"),t("br"),a._v("\n解决办法 在退出函数之前 将不使用的局部变量全部删除 变量=null"),t("br"),a._v("\n闭包可以做什么 节流和防抖")]),a._v(" "),t("h2",{attrs:{id:"节流和防抖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#节流和防抖"}},[a._v("#")]),a._v(" 节流和防抖")]),a._v(" "),t("p",[a._v("防抖 多次触发事件，只执行第一次或最后一次事件"),t("br"),a._v("\n节流 多次触发事件，只执行固定间隔时间的事件")])])}),[],!1,null,null,null);t.default=v.exports}}]);